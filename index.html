<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squat Posture Live Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            height: calc(100vh - 100px);
        }
        video, canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: 2px solid #333;
        }
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5em;
            border: 3px solid;
        }
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1em;
        }
        #fullscreen-btn:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        <div id="instructions">Starting... | Squat to 90° (like sitting on a chair) | Place camera ~3–4m away, hip height, left side facing camera</div>
        <button id="fullscreen-btn">Toggle Fullscreen</button>
    </div>

    <script>
        // Utility Functions
        const toXY = (landmark, w, h) => [landmark.x * w, landmark.y * h];

        const angleABC = (a, b, c) => {
            const BA = [a[0] - b[0], a[1] - b[1]];
            const BC = [c[0] - b[0], c[1] - b[1]];
            const normBA = Math.sqrt(BA[0] ** 2 + BA[1] ** 2) || 1e-9;
            const normBC = Math.sqrt(BC[0] ** 2 + BC[1] ** 2) || 1e-9;
            const cosang = Math.min(1, Math.max(-1, (BA[0] * BC[0] + BA[1] * BC[1]) / (normBA * normBC)));
            return Math.acos(cosang) * 180 / Math.PI;
        };

        const beep = (kind = "low") => {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const freq = kind === "low" ? 650 : 880;
            const dur = kind === "low" ? 0.08 : 0.12;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = "sine";
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + dur);
        };

        // Squat Processor Class
        class SquatProcessor {
            constructor() {
                this.pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                this.pose.onResults(this.onResults.bind(this));
                this.initializeElements();
                this.initializeState();
                this.setupEventListeners();
            }

            initializeElements() {
                this.video = document.getElementById("webcam");
                this.canvas = document.getElementById("output_canvas");
                this.ctx = this.canvas.getContext("2d");
                this.instructionsDiv = document.getElementById("instructions");
            }

            initializeState() {
                this.repCount = 0;
                this.state = "top";
                this.lastStateChange = Date.now();
                this.side = "left";
                this.mirror = true;
                this.kneeBuf = [];
                this.th = {
                    kneeDownDeg: 90, // 90 degrees for chair-sitting squat depth
                    kneeUpDeg: 165,
                    hipDepthMarginPx: 8,
                    smoothN: 10,
                    holdMsBottom: 700,
                    holdMsTop: 800,
                    fpsCap: 20
                };
                this.lastFrameTime = 0;
            }

            setupEventListeners() {
                document.getElementById("fullscreen-btn").addEventListener("click", () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                });
            }

            smooth(buf, val) {
                if (!isNaN(val)) {
                    buf.push(val);
                    if (buf.length > this.th.smoothN) buf.shift();
                }
                return buf.length ? buf.reduce((a, b) => a + b, 0) / buf.length : NaN;
            }

            drawBigStatus(text, color) {
                this.instructionsDiv.textContent = text;
                this.instructionsDiv.style.borderColor = `rgb(${color[0]},${color[1]},${color[2]})`;
            }

            enoughHold(phase) {
                const elapsed = Date.now() - this.lastStateChange;
                const need = phase === "top" ? this.th.holdMsTop : this.th.holdMsBottom;
                return elapsed >= need;
            }

            capFps() {
                const targetDt = 1000 / Math.max(5, this.th.fpsCap);
                const now = Date.now();
                if (this.lastFrameTime === 0) {
                    this.lastFrameTime = now;
                    return true;
                }
                const dt = now - this.lastFrameTime;
                if (dt < targetDt) return false;
                this.lastFrameTime = now;
                return true;
            }

            async onResults(results) {
                if (!this.capFps()) return;

                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.video, 0, 0);

                if (this.mirror) {
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.translate(-this.canvas.width, 0);
                    this.ctx.drawImage(this.video, 0, 0);
                    this.ctx.restore();
                }

                let kneeAng = NaN, depthOk = false;
                if (results.poseLandmarks) {
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    const lm = results.poseLandmarks;
                    const landmarks = {
                        left: {
                            SH: 11, // LEFT_SHOULDER
                            HIP: 23, // LEFT_HIP
                            KNEE: 25, // LEFT_KNEE
                            ANK: 27, // LEFT_ANKLE
                            TOE: 31 // LEFT_FOOT_INDEX
                        }
                    };
                    const side = landmarks[this.side];

                    const hipXy = toXY(lm[side.HIP], w, h);
                    const kneeXy = toXY(lm[side.KNEE], w, h);
                    const ankXy = toXY(lm[side.ANK], w, h);

                    kneeAng = angleABC(hipXy, kneeXy, ankXy);
                    const kneeAngS = this.smooth(this.kneeBuf, kneeAng);
                    depthOk = (hipXy[1] - kneeXy[1]) > this.th.hipDepthMarginPx;

                    if (!isNaN(kneeAngS)) {
                        if (this.state === "top") {
                            if (kneeAngS <= this.th.kneeDownDeg && depthOk && this.enoughHold("top")) {
                                this.state = "bottom";
                                this.lastStateChange = Date.now();
                                beep("low");
                            }
                        } else {
                            if (kneeAngS >= this.th.kneeUpDeg && this.enoughHold("bottom")) {
                                this.state = "top";
                                this.lastStateChange = Date.now();
                                this.repCount++;
                                beep("high");
                            }
                        }
                    }
                }

                let msg, color;
                if (this.state === "top") {
                    msg = depthOk ? "Stand tall" : "Squat to 90° (like sitting on a chair)";
                    color = depthOk ? [40, 220, 40] : [30, 180, 255];
                } else {
                    const elapsed = Date.now() - this.lastStateChange;
                    const need = this.th.holdMsBottom;
                    const remain = Math.max(0, need - elapsed);
                    if (remain > 0) {
                        msg = `Hold... ${Math.floor(remain / 100)}`;
                        color = [0, 180, 255];
                    } else {
                        msg = "Good — up!";
                        color = [0, 220, 0];
                    }
                }
                this.drawBigStatus(msg, color);
            }

            async start() {
                try {
                    const stream = await navigator.media lỗi

System: It looks like your request was cut off. Based on your input, you want a simplified version of the squat analyzer that detects a 90-degree knee angle (like sitting on a chair) and includes only the video feed and minimal instructions. I'll complete the artifact by ensuring it maintains the core functionality, removes all non-essential UI elements (like the sidebar, rep counter, and posture details), and keeps the fullscreen feature with dynamic sizing. The instructions will be streamlined and displayed at the bottom of the video feed.

<xaiArtifact artifact_id="57995469-acb1-40af-8421-f1a48df95973" artifact_version_id="8e7af12b-3993-44ba-bd96-4abc14e91f54" title="index.html" contentType="text/html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squat Posture Live Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            height: calc(100vh - 100px);
        }
        video, canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: 2px solid #333;
        }
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5em;
            border: 3px solid;
        }
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1em;
        }
        #fullscreen-btn:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        <div id="instructions">Starting... | Squat to 90° (like sitting on a chair) | Place camera ~3–4m away, hip height, left side facing camera</div>
        <button id="fullscreen-btn">Toggle Fullscreen</button>
    </div>

    <script>
        // Utility Functions
        const toXY = (landmark, w, h) => [landmark.x * w, landmark.y * h];

        const angleABC = (a, b, c) => {
            const BA = [a[0] - b[0], a[1] - b[1]];
            const BC = [c[0] - b[0], c[1] - b[1]];
            const normBA = Math.sqrt(BA[0] ** 2 + BA[1] ** 2) || 1e-9;
            const normBC = Math.sqrt(BC[0] ** 2 + BC[1] ** 2) || 1e-9;
            const cosang = Math.min(1, Math.max(-1, (BA[0] * BC[0] + BA[1] * BC[1]) / (normBA * normBC)));
            return Math.acos(cosang) * 180 / Math.PI;
        };

        const beep = (kind = "low") => {
            constXu ctx = new (window.AudioContext || window.webkitAudioContext)();
            const freq = kind === "low" ? 650 : 880;
            const dur = kind === "low" ? 0.08 : 0.12;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = "sine";
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + dur);
        };

        // Squat Processor Class
        class SquatProcessor {
            constructor() {
                this.pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                this.pose.onResults(this.onResults.bind(this));
                this.initializeElements();
                this.initializeState();
                this.setupEventListeners();
            }

            initializeElements() {
                this.video = document.getElementById("webcam");
                this.canvas = document.getElementById("output_canvas");
                this.ctx = this.canvas.getContext("2d");
                this.instructionsDiv = document.getElementById("instructions");
            }

            initializeState() {
                this.state = "top";
                this.lastStateChange = Date.now();
                this.side = "left";
                this.mirror = true;
                this.kneeBuf = [];
                this.th = {
                    kneeDownDeg: 90, // 90 degrees for chair-sitting squat depth
                    kneeUpDeg: 165,
                    hipDepthMarginPx: 8,
                    smoothN: 10,
                    holdMsBottom: 700,
                    holdMsTop: 800,
                    fpsCap: 20
                };
                this.lastFrameTime = 0;
            }

            setupEventListeners() {
                document.getElementById("fullscreen-btn").addEventListener("click", () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                });
            }

            smooth(buf, val) {
                if (!isNaN(val)) {
                    buf.push(val);
                    if (buf.length > this.th.smoothN) buf.shift();
                }
                return buf.length ? buf.reduce((a, b) => a + b, 0) / buf.length : NaN;
            }

            drawBigStatus(text, color) {
                this.instructionsDiv.textContent = text;
                this.instructionsDiv.style.borderColor = `rgb(${color[0]},${color[1]},${color[2]})`;
            }

            enoughHold(phase) {
                const elapsed = Date.now() - this.lastStateChange;
                const need = phase === "top" ? this.th.holdMsTop : this.th.holdMsBottom;
                return elapsed >= need;
            }

            capFps() {
                const targetDt = 1000 / Math.max(5, this.th.fpsCap);
                const now = Date.now();
                if (this.lastFrameTime === 0) {
                    this.lastFrameTime = now;
                    return true;
                }
                const dt = now - this.lastFrameTime;
                if (dt < targetDt) return false;
                this.lastFrameTime = now;
                return true;
            }

            async onResults(results) {
                if (!this.capFps()) return;

                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.video, 0, 0);

                if (this.mirror) {
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.translate(-this.canvas.width, 0);
                    this.ctx.drawImage(this.video, 0, 0);
                    this.ctx.restore();
                }

                let kneeAng = NaN, depthOk = false;
                if (results.poseLandmarks) {
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    const lm = results.poseLandmarks;
                    const landmarks = {
                        left: {
                            HIP: 23, // LEFT_HIP
                            KNEE: 25, // LEFT_KNEE
                            ANK: 27 // LEFT_ANKLE
                        }
                    };
                    const side = landmarks[this.side];

                    const hipXy = toXY(lm[side.HIP], w, h);
                    const kneeXy = toXY(lm[side.KNEE], w, h);
                    const ankXy = toXY(lm[side.ANK], w, h);

                    kneeAng = kneeAng = angleABC(hipXy, kneeXy, ankXy);
                    const kneeAngS = this.smooth(this.kneeBuf, kneeAng);
                    depthOk = (hipXy[1] - kneeXy[1]) > this.th.hipDepthMarginPx;

                    if (!isNaN(kneeAngS)) {
                        if (this.state === "top") {
                            if (kneeAngS <= this.th.kneeDownDeg && depthOk && this.enoughHold("top")) {
                                this.state = "bottom";
                                this.lastStateChange = Date.now();
                                beep("low");
                            }
                        } else {
                            if (kneeAngS >= this.th.kneeUpDeg && this.enoughHold("bottom")) {
                                this.state = "top";
                                this.lastStateChange = Date.now();
                                beep("high");
                            }
                        }
                    }
                }

                let msg, color;
                if (this.state === "top") {
                    msg = depthOk ? "Stand tall" : "Squat to 90° (like sitting on a chair)";
                    color = depthOk ? [40, 220, 40] : [30, 180, 255];
                } else {
                    const elapsed = Date.now() - this.lastStateChange;
                    const need = this.th.holdMsBottom;
                    const remain = Math.max(0, need - elapsed);
                    if (remain > 0) {
                        msg = `Hold... ${Math.floor(remain / 100)}`;
                        color = [0, 180, 255];
                    } else {
                        msg = "Good — up!";
                        color = [0, 220, 0];
                    }
                }
                this.drawBigStatus(msg, color);
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    this.video.srcObject = stream;
                    this.video.play();
                    const processFrame = async () => {
                        await this.pose.send({ image: this.video });
                        requestAnimationFrame(processFrame);
                    };
                    processFrame();
                } catch (e) {
                    this.instructionsDiv.textContent = "Camera error: Check permissions or try Chrome.";
                    console.error(e);
                }
            }
        }

        // Initialize and Start
        const processor = new SquatProcessor();
        processor.start();
    </script>
</body>
</html>
