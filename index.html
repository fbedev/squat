<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
<title>Squat 130Â° â€” Skeleton + Angles + Reps</title>
<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none; }
  #wrap { position:fixed; inset:0; }
  video, canvas { position:absolute; inset:0; width:100vw; height:100vh; object-fit:cover; }
  canvas { image-rendering: optimizeSpeed; }
  #flip, #mute {
    position:absolute; top:14px; width:44px; height:44px; border-radius:50%;
    background:rgba(0,0,0,.45); border:2px solid rgba(255,255,255,.85); color:#fff;
    display:flex; align-items:center; justify-content:center; font:600 14px system-ui,-apple-system,Segoe UI,Roboto;
    z-index:5; cursor:pointer; user-select:none;
  }
  #flip { right:14px; }
  #mute { right:66px; }
  #hud {
    position:absolute; left:16px; bottom:16px; z-index:5; color:#fff;
    font:600 32px system-ui,-apple-system,Segoe UI,Roboto; text-shadow:0 1px 2px rgba(0,0,0,.6);
  }
  #hud small { display:block; font:500 16px system-ui,-apple-system,Segoe UI,Roboto; opacity:.9; }
</style>
</head>
<body>
  <div id="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
    <div id="flip" title="Flip (front/back)" aria-label="Flip Camera">â†º</div>
    <div id="mute" title="Beep on/off" aria-label="Toggle Beep">ðŸ”ˆ</div>
    <div id="hud"><span id="reps">0</span><small>reps</small></div>
  </div>

  <!-- MediaPipe (camera + pose only) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469404/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>

<script>
(async () => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const flipBtn = document.getElementById('flip');
  const muteBtn = document.getElementById('mute');
  const repsEl = document.getElementById('reps');

  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', resize); resize();

  // ==== camera + flip ====
  let currentFacing = 'environment', currentStream = null;
  async function stopStream(){ if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; } }
  async function chooseDeviceIdForFacing(facing){
    const devs = await navigator.mediaDevices.enumerateDevices().catch(()=>[]);
    const cams = devs.filter(d=>d.kind==='videoinput');
    if(!cams.length) return null;
    const re = facing==='environment' ? /(back|rear|environment)/i : /(front|user|face)/i;
    const m = cams.find(c=>re.test(c.label));
    if (m) return m.deviceId;
    return facing==='environment' ? (cams[cams.length-1]?.deviceId ?? cams[0]?.deviceId)
                                  : (cams[0]?.deviceId ?? null);
  }
  async function initCamera(facing='environment'){
    currentFacing = facing;
    await stopStream();
    let stream;
    try{
      const id = await chooseDeviceIdForFacing(facing);
      const constraint = id ? { deviceId:{ exact:id } } : { facingMode:{ ideal:facing } };
      stream = await navigator.mediaDevices.getUserMedia({
        video: Object.assign(constraint, { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30,max:30} }),
        audio:false
      });
    }catch(e){
      stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
    }
    currentStream = stream; video.srcObject = stream;
    await video.play().catch(()=>{});
    video.style.transform = (currentFacing==='user') ? 'scaleX(-1)' : 'none';
  }
  async function flipCamera(){ await initCamera(currentFacing==='environment' ? 'user' : 'environment'); }
  flipBtn.onclick = flipCamera;
  document.addEventListener('keydown', e => { if(e.key.toLowerCase()==='f') flipCamera(); });
  document.addEventListener('touchstart', ()=>{ if(video.paused) video.play().catch(()=>{}); }, {passive:true});
  await initCamera('environment');

  // ==== beep ====
  let audioCtx = null, beepOn = true;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
  function beep(){
    if(!beepOn) return;
    ensureAudio();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type='sine'; o.frequency.value=880; g.gain.value=0.001;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime+0.15);
    o.stop(audioCtx.currentTime+0.16);
  }
  muteBtn.onclick = () => { beepOn = !beepOn; muteBtn.textContent = beepOn ? 'ðŸ”ˆ' : 'ðŸ”‡'; };

  // ==== Pose ====
  const pose = new Pose({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${f}`
  });
  pose.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    enableSegmentation: false,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  let last = null, noLandmarkFrames = 0;
  pose.onResults(r => { last = r; });

  // ==== helpers ====
  function mirrorIfFront(lm){ return currentFacing!=='user' ? lm : lm.map(p => ({...p, x: 1 - p.x})); }
  function toPx(p,W,H){ return { x:p.x*W, y:p.y*H }; }
  function angleAt(B,A,C){
    const bax=A.x-B.x, bay=A.y-B.y; const bcx=C.x-B.x, bcy=C.y-B.y;
    const dot=bax*bcx+bay*bcy, ab=Math.hypot(bax,bay), cb=Math.hypot(bcx,bcy);
    if(!ab||!cb) return NaN;
    let cos=dot/(ab*cb); cos=Math.max(-1,Math.min(1,cos));
    return Math.acos(cos)*180/Math.PI;
  }
  function sidePick(lm){
    const L=[23,25,27,31], R=[24,26,28,32];
    const sum = ids => ids.map(i=>lm[i]?.visibility??0).reduce((a,b)=>a+b,0);
    return sum(L) >= sum(R) ? 'L' : 'R';
  }
  function legLm(lm, side){
    return side==='L'
      ? {hip:lm[23], knee:lm[25], ankle:lm[27], heel:lm[29], foot:lm[31], kneeOther:lm[26]}
      : {hip:lm[24], knee:lm[26], ankle:lm[28], heel:lm[30], foot:lm[32], kneeOther:lm[25]};
  }

  // ==== drawing helpers ====
  const CONNECTIONS = [
    [11,13],[13,15],[12,14],[14,16],
    [11,12],[23,24],[11,23],[12,24],
    [23,25],[25,27],[27,29],[27,31],
    [24,26],[26,28],[28,30],[28,32]
  ];
  function drawConnectorsLocal(ctx, lm, connections, opt={}) {
    const color = opt.color || '#00FF7F';
    const lineWidth = opt.lineWidth || 3;
    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.save();
    ctx.strokeStyle = color; ctx.lineWidth = lineWidth;
    for (const [i,j] of connections) {
      const a = lm[i], b = lm[j];
      if (!a || !b) continue;
      if ((a.visibility!=null && a.visibility<0.3) || (b.visibility!=null && b.visibility<0.3)) continue;
      ctx.beginPath();
      ctx.moveTo(a.x*W, a.y*H);
      ctx.lineTo(b.x*W, b.y*H);
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawLandmarksLocal(ctx, lm, opt={}) {
    const color = opt.color || '#FFFFFF';
    const radius = opt.radius || 2;
    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.save(); ctx.fillStyle = color;
    for (const p of lm) {
      if (!p) continue;
      if (p.visibility!=null && p.visibility<0.3) continue;
      ctx.beginPath();
      ctx.arc(p.x*W, p.y*H, radius, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ==== smoothing + reps (130Â° target) ====
  const kBuf=[]; const aBuf=[]; const BUF=8;
  const smooth = (buf,v)=>{ buf.push(v); if(buf.length>BUF) buf.shift(); return buf.reduce((x,y)=>x+y,0)/buf.length; };

  let reps=0, phase='up', atTargetFrames=0;
  const K_STAND=160, K_TARGET_MIN=126, K_TARGET_MAX=134;

  function updateReps(kneeAngle){
    if (kneeAngle>=K_TARGET_MIN && kneeAngle<=K_TARGET_MAX) {
      if (phase!=='atTarget') atTargetFrames=0;
      phase='atTarget'; atTargetFrames++;
    } else if (kneeAngle < K_TARGET_MIN) {
      phase='down'; atTargetFrames=0;
    } else if (kneeAngle > K_TARGET_MAX) {
      if ((phase==='atTarget'||phase==='down') && atTargetFrames>=5 && kneeAngle>(K_STAND-5)) {
        reps++; repsEl.textContent = reps; beep();
      }
      phase='up'; atTargetFrames=0;
    }
  }

  function badge(text,x,y){
    ctx.font='bold 24px system-ui,-apple-system,Segoe UI,Roboto';
    const w=ctx.measureText(text).width+16;
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(x,y-28,w,32);
    ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=2; ctx.strokeRect(x,y-28,w,32);
    ctx.fillStyle='#fff'; ctx.fillText(text,x+8,y-6);
  }

  // ==== main loop ====
  async function tick(){
    if (video.readyState >= 2) await pose.send({ image: video });
    const W=canvas.width,H=canvas.height; ctx.clearRect(0,0,W,H);

    if (last?.poseLandmarks) {
      noLandmarkFrames=0;
      const lm=mirrorIfFront(last.poseLandmarks);
      drawConnectorsLocal(ctx,lm,CONNECTIONS,{color:'#00FF7F',lineWidth:3});
      drawLandmarksLocal(ctx,lm,{color:'#FFFFFF',radius:2});

      const side=sidePick(lm); const L=legLm(lm,side);
      const pHip=toPx(L.hip,W,H), pKnee=toPx(L.knee,W,H), pAnk=toPx(L.ankle,W,H);
      const pFoot=L.foot?toPx(L.foot,W,H):pAnk;
      const pKneeO=L.kneeOther?toPx(L.kneeOther,W,H):pKnee;

      ctx.lineWidth=6; ctx.strokeStyle='rgba(0,255,180,.95)';
      ctx.beginPath(); ctx.moveTo(pHip.x,pHip.y); ctx.lineTo(pKnee.x,pKnee.y); ctx.lineTo(pAnk.x,pAnk.y); ctx.lineTo(pFoot.x,pFoot.y); ctx.stroke();
      [pHip,pKnee,pAnk,pFoot].forEach(pt=>{ ctx.beginPath(); ctx.arc(pt.x,pt.y,6,0,Math.PI*2); ctx.fillStyle='#00ffc8'; ctx.fill(); });

      let kneeAngle=angleAt(L.knee,L.hip,L.ankle);
      let ankleRef=(L.foot??L.heel??L.ankle);
      let ankleAngle=angleAt(L.ankle,L.knee,ankleRef);
      kneeAngle=smooth(kBuf,kneeAngle); ankleAngle=smooth(aBuf,ankleAngle);

      const chairY=(pKnee.y+pKneeO.y)/2;
      ctx.setLineDash([10,10]); ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.7)';
      ctx.beginPath(); ctx.moveTo(0,chairY); ctx.lineTo(W,chairY); ctx.stroke(); ctx.setLineDash([]);
      ctx.font='18px system-ui,-apple-system,Segoe UI,Roboto'; ctx.fillStyle='rgba(255,255,255,.9)';
      ctx.fillText('Target: hips down to this line (â‰ˆ130Â°)',16,Math.max(22,chairY-8));

      badge(`${Math.round(kneeAngle)}Â° knee`,pKnee.x+14,pKnee.y-12);
      badge(`${Math.round(ankleAngle)}Â° ankle`,pAnk.x+14,pAnk.y-12);

      const barH=H*0.6, barW=10, barX=W-28, barY=(H-barH)/2;
      ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(barX,barY,barW,barH);
      const y130=barY+((180-130)/90)*barH;
      ctx.fillStyle='#fff'; ctx.fillRect(barX-6,y130-2,barW+12,4);
      const kClamp=Math.max(90,Math.min(180,kneeAngle));
      const yNow=barY+((180-kClamp)/90)*barH;
      ctx.fillStyle='#00ffc8'; ctx.fillRect(barX-2,yNow-3,barW+4,6);

      ctx.beginPath(); ctx.moveTo(pHip.x,pHip.y); ctx.lineTo(pHip.x,chairY);
      ctx.strokeStyle=(pHip.y-chairY)>6?'#ff7676':'#00ffc8'; ctx.lineWidth=3; ctx.stroke();

      let msg='',color='#fff';
      if (kneeAngle>=K_STAND){ msg='Start: go down slowly'; color='#fff'; }
      else if (kneeAngle>K_TARGET_MAX){ msg='Lowerâ€¦ aim for 130Â°'; color='#ffeb3b'; }
      else if (kneeAngle>=K_TARGET_MIN){ msg='Perfect 130Â° â€” hold briefly'; color='#00ffc8'; }
      else { msg='Too deep â€” rise a bit'; color='#ff7676'; }
      ctx.font='600 32px system-ui,-apple-system,Segoe UI,Roboto'; ctx.textAlign='center';
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(W/2-300,24,600,50);
      ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=2; ctx.strokeRect(W/2-300,24,600,50);
      ctx.fillStyle=color; ctx.fillText(msg,W/2,60);

      updateReps(kneeAngle);
    } else {
      noLandmarkFrames++;
      if (noLandmarkFrames>15){
        ctx.font='600 22px system-ui,-apple-system,Segoe UI,Roboto'; ctx.fillStyle='rgba(255,255,255,.9)';
        ctx.textAlign='center'; ctx.fillText('Step back so hips/knees/ankles/feet are visible',W/2,40);
      }
    }
    requestAnimationFrame(tick);
  }

  if (video.readyState>=2) tick();
  else video.addEventListener('loadeddata',tick,{once:true});
})();
</script>
</body>
</html>
