<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1"
  />
  <title>Squat 90° — Fullscreen Web</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none; user-select: none;
    }
    #wrap { position: fixed; inset: 0; }
    video, canvas {
      position: absolute; inset: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;
    }
    /* keep overlays crisp on mobile */
    canvas { image-rendering: optimizeSpeed; }
  </style>
</head>
<body>
  <div id="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <!-- MediaPipe (classic solutions) via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469404/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675469404/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>

  <script>
  (async () => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    // ====== layout ======
    function resize() {
      const w = window.innerWidth, h = window.innerHeight;
      canvas.width = w; canvas.height = h;
    }
    window.addEventListener('resize', resize);
    resize();

    // ====== camera (rear by default) ======
    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: 'environment' },
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30, max: 30 }
          },
          audio: false
        });
        video.srcObject = stream;
        await video.play().catch(()=>{});
      } catch (e) {
        // fallback to any camera
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        video.srcObject = stream;
        await video.play().catch(()=>{});
      }
    }

    // wake video on tap if iOS blocks autoplay
    document.addEventListener('touchstart', () => {
      if (video.paused) video.play().catch(()=>{});
    }, { passive: true });

    await initCamera();

    // ====== mediapipe pose ======
    const pose = new Pose.Pose({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let lastResults = null;
    pose.onResults((r) => { lastResults = r; });

    // ====== helpers ======
    function lerp(a, b, t){ return a + (b - a) * t; }

    function angleAt(B, A, C) {
      // angle ABC in degrees
      const bax = A.x - B.x, bay = A.y - B.y;
      const bcx = C.x - B.x, bcy = C.y - B.y;
      const dot = bax*bcx + bay*bcy;
      const ab = Math.hypot(bax, bay), cb = Math.hypot(bcx, bcy);
      if (ab === 0 || cb === 0) return NaN;
      let cos = dot / (ab * cb);
      cos = Math.max(-1, Math.min(1, cos));
      return Math.acos(cos) * 180 / Math.PI;
    }

    function pickSide(lm) {
      // choose leg (L/R) with higher average visibility: hip, knee, ankle
      const L = [23,25,27], R = [24,26,28]; // hip,knee,ankle
      const vL = L.map(i=>lm[i].visibility??0).reduce((a,b)=>a+b,0);
      const vR = R.map(i=>lm[i].visibility??0).reduce((a,b)=>a+b,0);
      return vL >= vR ? 'L' : 'R';
    }

    function getLegLandmarks(lm, side) {
      const ids = side === 'L'
        ? {hip:23, knee:25, ankle:27}
        : {hip:24, knee:26, ankle:28};
      return {
        hip: lm[ids.hip],
        knee: lm[ids.knee],
        ankle: lm[ids.ankle]
      };
    }

    // smoothing buffer
    const angleBuf = [];
    const BUF = 8;
    function smoothPush(v) {
      angleBuf.push(v);
      if (angleBuf.length > BUF) angleBuf.shift();
      return angleBuf.reduce((a,b)=>a+b,0) / angleBuf.length;
    }

    // squat state
    let state = 'stand'; // 'stand' | 'down' | 'hold' | 'deep'
    let holdFrames = 0;

    // ====== main loop ======
    async function tick() {
      if (video.readyState >= 2) {
        await pose.send({ image: video });
      }

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (lastResults && lastResults.poseLandmarks) {
        const lm = lastResults.poseLandmarks;

        // choose side automatically
        const side = pickSide(lm);
        const {hip, knee, ankle} = getLegLandmarks(lm, side);

        // map normalized [0..1] to pixels (video is object-fit: cover, but normalized still fits canvas)
        const W = canvas.width, H = canvas.height;
        function toPx(p){ return { x: p.x * W, y: p.y * H}; }
        const pHip = toPx(hip), pKnee = toPx(knee), pAnk = toPx(ankle);

        // knee angle (thigh vs shin)
        let rawAngle = angleAt({x:knee.x, y:knee.y}, {x:hip.x, y:hip.y}, {x:ankle.x, y:ankle.y});
        let angle = smoothPush(rawAngle);

        // dynamic "chair line" = knee height (hip should drop to ~ this y at 90°)
        const chairY = (pKnee.y + toPx(side==='L' ? lm[26] : lm[25]).y) / 2 || pKnee.y; // avg both knees if possible
        ctx.save();
        ctx.setLineDash([10,10]);
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath();
        ctx.moveTo(0, chairY);
        ctx.lineTo(W, chairY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillText('Target: bring hips down to this line (≈ 90°)', 16, Math.max(24, chairY - 8));
        ctx.restore();

        // draw leg segments
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(0,255,180,0.9)';
        ctx.beginPath(); ctx.moveTo(pHip.x, pHip.y); ctx.lineTo(pKnee.x, pKnee.y); ctx.lineTo(pAnk.x, pAnk.y); ctx.stroke();
        // joints
        [pHip, pKnee, pAnk].forEach(pt => {
          ctx.beginPath(); ctx.arc(pt.x, pt.y, 6, 0, Math.PI*2); ctx.fillStyle = '#00ffc8'; ctx.fill();
        });

        // angle badge near knee
        const badge = `${Math.round(angle)}°`;
        ctx.font = 'bold 22px system-ui, -apple-system, Segoe UI, Roboto';
        const badgeW = ctx.measureText(badge).width + 16;
        const bx = pKnee.x + 14, by = pKnee.y - 14;
        ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(bx, by-26, badgeW, 30);
        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 2; ctx.strokeRect(bx, by-26, badgeW, 30);
        ctx.fillStyle = '#ffffff'; ctx.fillText(badge, bx+8, by-6);

        // progress bar (right edge): 180° (top) -> 90° (marker)
        const barH = H * 0.6, barW = 10, barX = W - 28, barY = (H - barH)/2;
        ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(barX, barY, barW, barH);
        // marker at 90°
        const frac90 = (180 - 90) / 90; // 1.0 at 90°
        const y90 = barY + frac90 * barH;
        ctx.fillStyle = '#ffffff'; ctx.fillRect(barX - 6, y90 - 2, barW + 12, 4);

        // current angle marker
        const clamped = Math.max(90, Math.min(180, angle));
        const frac = (180 - clamped) / 90;
        const yNow = lerp(barY, barY + barH, frac);
        ctx.fillStyle = '#00ffc8'; ctx.fillRect(barX - 2, yNow - 3, barW + 4, 6);

        // state machine
        // thresholds with a little hysteresis to reduce flicker
        const STAND_T = 160, DOWN_T = 100, HOLD_MIN = 86, HOLD_MAX = 94;
        if (angle >= STAND_T) { state = 'stand'; holdFrames = 0; }
        else if (angle > HOLD_MAX && angle < STAND_T) { state = 'down'; holdFrames = 0; }
        else if (angle >= HOLD_MIN && angle <= HOLD_MAX) {
          state = 'hold'; holdFrames++;
        } else if (angle < HOLD_MIN) {
          state = 'deep'; holdFrames = 0;
        }

        // central coaching text
        let msg = '', color = '#ffffff';
        if (state === 'stand')      { msg = 'Start: go down slowly'; color = '#ffffff'; }
        else if (state === 'down')  { msg = 'Lower… aim for 90°';    color = '#ffeb3b'; }
        else if (state === 'hold')  { msg = holdFrames > 30 ? 'Perfect 90° — hold steady' : 'Almost there… hold'; color = '#00ffc8'; }
        else if (state === 'deep')  { msg = 'Too deep — rise a bit'; color = '#ff7676'; }

        ctx.font = '600 28px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fillRect(W/2 - 240, 28, 480, 46);
        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 2;
        ctx.strokeRect(W/2 - 240, 28, 480, 46);
        ctx.fillStyle = color; ctx.fillText(msg, W/2, 60);

        // hip vs chair line cue (tiny arrow)
        const diff = pHip.y - chairY; // + = below line (deeper)
        ctx.beginPath();
        ctx.moveTo(pHip.x, pHip.y);
        ctx.lineTo(pHip.x, chairY);
        ctx.strokeStyle = diff > 6 ? '#ff7676' : '#00ffc8';
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      // schedule next frame
      // (use requestAnimationFrame for smooth draw; MPose internal throttling handles perf)
      requestAnimationFrame(tick);
    }

    // kick off once video metadata is ready
    if (video.readyState >= 2) tick();
    else video.addEventListener('loadeddata', tick, { once: true });
  })();
  </script>
</body>
</html>