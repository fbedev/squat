<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
<title>Squat 90Â° â€” Angles + Reps</title>
<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none; }
  #wrap { position:fixed; inset:0; }
  video, canvas { position:absolute; inset:0; width:100vw; height:100vh; object-fit:cover; }
  canvas { image-rendering: optimizeSpeed; }
  #flip, #mute {
    position:absolute; top:14px; width:44px; height:44px; border-radius:50%;
    background:rgba(0,0,0,.45); border:2px solid rgba(255,255,255,.85); color:#fff;
    display:flex; align-items:center; justify-content:center; font:600 14px system-ui,-apple-system,Segoe UI,Roboto;
    z-index:5; cursor:pointer; user-select:none;
  }
  #flip { right:14px; }
  #mute { right:66px; }
  #hud {
    position:absolute; left:16px; bottom:16px; z-index:5; color:#fff;
    font:600 28px system-ui,-apple-system,Segoe UI,Roboto;
    text-shadow: 0 1px 2px rgba(0,0,0,.6);
  }
  #hud small { display:block; font:500 14px system-ui,-apple-system,Segoe UI,Roboto; opacity:.9; }
</style>
</head>
<body>
  <div id="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
    <div id="flip" title="Flip (front/back)" aria-label="Flip Camera">â†º</div>
    <div id="mute" title="Beep on/off" aria-label="Toggle Beep">ðŸ”ˆ</div>
    <div id="hud"><span id="reps">0</span><small>reps</small></div>
  </div>

  <!-- MediaPipe (classic solutions) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469404/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675469404/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>

<script>
(async () => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const flipBtn = document.getElementById('flip');
  const muteBtn = document.getElementById('mute');
  const repsEl = document.getElementById('reps');

  // layout
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', resize); resize();

  // camera + flip
  let currentFacing = 'environment', currentStream = null;
  async function stopStream(){ if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; } }
  async function chooseDeviceIdForFacing(facing){
    const devs = await navigator.mediaDevices.enumerateDevices().catch(()=>[]);
    const cams = devs.filter(d=>d.kind==='videoinput');
    if(!cams.length) return null;
    const re = facing==='environment' ? /(back|rear|environment)/i : /(front|user|face)/i;
    const m = cams.find(c=>re.test(c.label));
    if (m) return m.deviceId;
    return facing==='environment' ? (cams[cams.length-1]?.deviceId ?? cams[0].deviceId)
                                  : (cams[0]?.deviceId ?? null);
  }
  async function initCamera(facing='environment'){
    currentFacing = facing;
    await stopStream();
    let stream;
    try{
      const id = await chooseDeviceIdForFacing(facing);
      const constraint = id ? { deviceId:{ exact:id } } : { facingMode:{ ideal:facing } };
      stream = await navigator.mediaDevices.getUserMedia({
        video: Object.assign(constraint, { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30,max:30} }),
        audio:false
      });
    }catch(e){
      stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
    }
    currentStream = stream; video.srcObject = stream;
    await video.play().catch(()=>{});
    video.style.transform = (currentFacing==='user') ? 'scaleX(-1)' : 'none';
  }
  async function flipCamera(){
    await initCamera(currentFacing==='environment' ? 'user' : 'environment');
  }
  flipBtn.onclick = flipCamera;
  document.addEventListener('keydown', e => { if(e.key.toLowerCase()==='f') flipCamera(); });

  // iOS autoplay nudge
  document.addEventListener('touchstart', ()=>{ if(video.paused) video.play().catch(()=>{}); }, {passive:true});
  await initCamera('environment');

  // beep (WebAudio)
  let audioCtx = null, beepOn = true;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
  function beep(){
    if(!beepOn) return;
    ensureAudio();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = 880; // A5
    g.gain.value = 0.001; // soft
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.15);
    o.stop(audioCtx.currentTime + 0.16);
  }
  muteBtn.onclick = () => {
    beepOn = !beepOn;
    muteBtn.textContent = beepOn ? 'ðŸ”ˆ' : 'ðŸ”‡';
  };

  // MediaPipe Pose
  const pose = new Pose.Pose({
    locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${f}`
  });
  pose.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    enableSegmentation: false,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  let last = null;
  pose.onResults(r => { last = r; });

  // helpers
  const lerp = (a,b,t)=>a+(b-a)*t;
  function toPx(p,W,H){
    const xNorm = (currentFacing==='user') ? (1 - p.x) : p.x; // mirror overlays with front cam
    return { x:xNorm*W, y:p.y*H };
  }
  function angleAt(B,A,C){
    const bax=A.x-B.x, bay=A.y-B.y; const bcx=C.x-B.x, bcy=C.y-B.y;
    const dot=bax*bcx+bay*bcy, ab=Math.hypot(bax,bay), cb=Math.hypot(bcx,bcy);
    if(!ab||!cb) return NaN;
    let cos=dot/(ab*cb); cos=Math.max(-1,Math.min(1,cos));
    return Math.acos(cos)*180/Math.PI;
  }
  function sidePick(lm){
    const L=[23,25,27], R=[24,26,28];
    const sum = ids => ids.map(i=>lm[i]?.visibility??0).reduce((a,b)=>a+b,0);
    return sum(L) >= sum(R) ? 'L' : 'R';
  }
  function legLm(lm, side){
    return side==='L'
      ? {hip:lm[23], knee:lm[25], ankle:lm[27], heel:lm[29], foot:lm[31], kneeOther:lm[26]}
      : {hip:lm[24], knee:lm[26], ankle:lm[28], heel:lm[30], foot:lm[32], kneeOther:lm[25]};
  }

  // smoothing
  const kBuf=[]; const aBuf=[]; const BUF=8;
  const smoothK = v => { kBuf.push(v); if(kBuf.length>BUF) kBuf.shift(); return kBuf.reduce((x,y)=>x+y,0)/kBuf.length; };
  const smoothA = v => { aBuf.push(v); if(aBuf.length>BUF) aBuf.shift(); return aBuf.reduce((x,y)=>x+y,0)/aBuf.length; };

  // rep counter (state machine)
  let reps=0, phase='up'; // 'up'|'down'|'at90'
  let at90Frames=0;

  const K_STAND=160;      // knee angle considered standing
  const K_DOWN=110;       // below this => considered 'down'
  const K_90_MIN=86, K_90_MAX=94; // 90Â° window

  function updateReps(kneeAngle){
    // entering the 90 window
    if (kneeAngle>=K_90_MIN && kneeAngle<=K_90_MAX) {
      if (phase!=='at90') at90Frames=0;
      phase='at90'; at90Frames++;
    } else if (kneeAngle < K_90_MIN) {
      phase='down'; at90Frames=0;
    } else if (kneeAngle > K_90_MAX) {
      // if just left 90 window going up and previously deep enough => count
      if (phase==='at90' || phase==='down') {
        // confirm we actually hit the window for a few frames to avoid false reps
        if (at90Frames >= 5 && kneeAngle > K_STAND-5) {
          reps++; repsEl.textContent = reps; beep();
        }
      }
      phase='up'; at90Frames=0;
    }
  }

  // draw badge
  function badge(text, x, y){
    ctx.font='bold 20px system-ui,-apple-system,Segoe UI,Roboto';
    const w = ctx.measureText(text).width + 16;
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(x, y-24, w, 28);
    ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=2; ctx.strokeRect(x, y-24, w, 28);
    ctx.fillStyle='#fff'; ctx.fillText(text, x+8, y-5);
  }

  // main loop
  async function tick(){
    if (video.readyState >= 2) await pose.send({ image: video });

    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    if (last?.poseLandmarks) {
      const lm = last.poseLandmarks;
      const side = sidePick(lm);
      const L = legLm(lm, side);

      // px coords
      const pHip = toPx(L.hip,W,H), pKnee = toPx(L.knee,W,H), pAnk = toPx(L.ankle,W,H);
      const pHeel = L.heel ? toPx(L.heel,W,H) : pAnk;
      const pFoot = L.foot ? toPx(L.foot,W,H) : pAnk;
      const pKneeO = L.kneeOther ? toPx(L.kneeOther,W,H) : pKnee;

      // angles
      let kneeAngle = angleAt({x:L.knee.x,y:L.knee.y},{x:L.hip.x,y:L.hip.y},{x:L.ankle.x,y:L.ankle.y});
      let ankleAngle = angleAt({x:L.ankle.x,y:L.ankle.y},{x:L.knee.x,y:L.knee.y},{x:(L.foot?.x ?? L.heel?.x ?? L.ankle.x), y:(L.foot?.y ?? L.heel?.y ?? L.ankle.y)});
      kneeAngle = smoothK(kneeAngle);
      ankleAngle = smoothA(ankleAngle);

      // â€œchair lineâ€ at knee height
      const chairY = (pKnee.y + pKneeO.y)/2;
      ctx.setLineDash([10,10]); ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.7)';
      ctx.beginPath(); ctx.moveTo(0, chairY); ctx.lineTo(W, chairY); ctx.stroke();
      ctx.setLineDash([]);
      ctx.font='16px system-ui,-apple-system,Segoe UI,Roboto';
      ctx.fillStyle='rgba(255,255,255,.9)';
      ctx.fillText('Target: hips down to this line (â‰ˆ 90Â°)', 16, Math.max(22, chairY-8));

      // draw leg polyline hipâ†’kneeâ†’ankleâ†’foot
      ctx.lineWidth=6; ctx.strokeStyle='rgba(0,255,180,.9)';
      ctx.beginPath();
      ctx.moveTo(pHip.x,pHip.y); ctx.lineTo(pKnee.x,pKnee.y); ctx.lineTo(pAnk.x,pAnk.y);
      ctx.lineTo(pFoot.x,pFoot.y); ctx.stroke();
      [pHip,pKnee,pAnk,pFoot].forEach(pt=>{ ctx.beginPath(); ctx.arc(pt.x,pt.y,6,0,Math.PI*2); ctx.fillStyle='#00ffc8'; ctx.fill(); });

      // knee angle badge
      badge(`${Math.round(kneeAngle)}Â° knee`, pKnee.x + 14, pKnee.y - 12);
      // ankle/â€œshoeâ€ angle badge
      badge(`${Math.round(ankleAngle)}Â° ankle`, pAnk.x + 14, pAnk.y - 12);

      // side progress bar to visualize knee angle (180â†’90)
      const barH=H*0.6, barW=10, barX=W-28, barY=(H-barH)/2;
      ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(barX,barY,barW,barH);
      const y90 = barY + ((180-90)/90)*barH;
      ctx.fillStyle='#fff'; ctx.fillRect(barX-6,y90-2,barW+12,4);
      const kClamp = Math.max(90, Math.min(180, kneeAngle));
      const yNow = barY + ((180 - kClamp)/90)*barH;
      ctx.fillStyle='#00ffc8'; ctx.fillRect(barX-2,yNow-3,barW+4,6);

      // hip vs chair cue
      ctx.beginPath(); ctx.moveTo(pHip.x,pHip.y); ctx.lineTo(pHip.x, chairY);
      ctx.strokeStyle = (pHip.y - chairY) > 6 ? '#ff7676' : '#00ffc8'; ctx.lineWidth=3; ctx.stroke();

      // coaching text
      let msg='', color='#fff';
      if (kneeAngle >= K_STAND) { msg='Start: go down slowly'; color='#fff'; }
      else if (kneeAngle > K_90_MAX) { msg='Lowerâ€¦ aim for 90Â°'; color='#ffeb3b'; }
      else if (kneeAngle >= K_90_MIN && kneeAngle <= K_90_MAX) { msg='Perfect 90Â° â€” hold briefly'; color='#00ffc8'; }
      else { msg='Too deep â€” rise a bit'; color='#ff7676'; }
      ctx.font='600 28px system-ui,-apple-system,Segoe UI,Roboto';
      ctx.textAlign='center';
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(W/2-260, 24, 520, 46);
      ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=2; ctx.strokeRect(W/2-260,24,520,46);
      ctx.fillStyle=color; ctx.fillText(msg, W/2, 56);

      // update reps
      updateReps(kneeAngle);
    }

    requestAnimationFrame(tick);
  }

  if (video.readyState >= 2) tick();
  else video.addEventListener('loadeddata', tick, { once:true });
})();
</script>
</body>
</html>