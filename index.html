<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squat Posture Live Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
        }
        #main {
            flex: 3;
            padding: 20px;
            text-align: center;
        }
        #sidebar {
            flex: 1;
            padding: 20px;
            background-color: #e0e0e0;
            border-left: 2px solid #ccc;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        video, canvas {
            width: 100%;
            max-width: 640px;
            border: 2px solid #333;
        }
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .video-container {
            position: relative;
            display: inline-block;
        }
        .grandma-mode {
            font-size: 2em !important;
            font-weight: bold;
        }
        input, label {
            margin: 5px 0;
            display: block;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 2em;
            border: 3px solid;
        }
        #rep-count {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5em;
        }
        #posture-details {
            position: absolute;
            top: 60px;
            left: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div id="main">
        <h1>üèãÔ∏è Squat Posture Live Analyzer</h1>
        <p>Side view (left side facing camera) ¬∑ Educational only ¬∑ Uses your browser webcam</p>
        <div class="video-container">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="output_canvas"></canvas>
            <div id="status">Starting...</div>
            <div id="rep-count">Reps: 0</div>
            <div id="posture-details"></div>
        </div>
        <p><strong>Tip</strong>: Place camera ~3‚Äì4m away at hip height, perpendicular to your left side. Keep entire body in frame. Wear contrasting clothes.</p>
    </div>
    <div id="sidebar">
        <h2>Settings</h2>
        <label><input type="checkbox" id="show-lines" checked> Show helper lines</label>
        <label><input type="checkbox" id="audible-beep" checked> Beep at bottom/top</label>
    </div>

    <script>
        // Geometry Utils
        function toXY(landmark, w, h) {
            return [landmark.x * w, landmark.y * h];
        }

        function angleABC(a, b, c) {
            const BA = [a[0] - b[0], a[1] - b[1]];
            const BC = [c[0] - b[0], c[1] - b[1]];
            const normBA = Math.sqrt(BA[0] ** 2 + BA[1] ** 2) || 1e-9;
            const normBC = Math.sqrt(BC[0] ** 2 + BC[1] ** 2) || 1e-9;
            const cosang = Math.min(1, Math.max(-1, (BA[0] * BC[0] + BA[1] * BC[1]) / (normBA * normBC)));
            return Math.acos(cosang) * 180 / Math.PI;
        }

        // Beep Utility
        function beep(kind = "low") {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const freq = kind === "low" ? 650 : 880;
            const dur = kind === "low" ? 0.08 : 0.12;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = "sine";
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + dur);
        }

        // Squat Processor
        class SquatProcessor {
            constructor() {
                this.pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                this.pose.onResults(this.onResults.bind(this));
                this.repCount = 0;
                this.state = "top";
                this.lastStateChange = Date.now();
                this.side = "left";
                this.mirror = true;
                this.grandmaMode = true;
                this.showLines = true;
                this.audibleBeep = true;
                this.kneeBuf = [];
                this.hipBuf = [];
                this.ankleBuf = [];
                this.th = {
                    kneeDownDeg: 100,
                    kneeUpDeg: 165,
                    hipDepthMarginPx: 8,
                    smoothN: 10,
                    holdMsBottom: 700,
                    holdMsTop: 800,
                    fpsCap: 20
                };
                this.lastFrameTime = 0;
                this.video = document.getElementById("webcam");
                this.canvas = document.getElementById("output_canvas");
                this.ctx = this.canvas.getContext("2d");
                this.statusDiv = document.getElementById("status");
                this.repDiv = document.getElementById("rep-count");
                this.postureDiv = document.getElementById("posture-details");
            }

            smooth(buf, val) {
                if (!isNaN(val)) {
                    buf.push(val);
                    if (buf.length > this.th.smoothN) buf.shift();
                }
                return buf.length ? buf.reduce((a, b) => a + b, 0) / buf.length : NaN;
            }

            drawText(text, x, y, scale = 0.7, color = "white", thick = 2) {
                this.ctx.font = `${scale * 20}px Arial`;
                this.ctx.lineWidth = thick + 3;
                this.ctx.strokeStyle = "black";
                this.ctx.strokeText(text, x, y);
                this.ctx.fillStyle = color;
                this.ctx.fillText(text, x, y);
            }

            drawBigStatus(text, color) {
                this.statusDiv.textContent = text;
                this.statusDiv.style.borderColor = `rgb(${color[0]},${color[1]},${color[2]})`;
                this.statusDiv.style.fontSize = "2em";
            }

            enoughHold(phase) {
                const elapsed = Date.now() - this.lastStateChange;
                const need = phase === "top" ? this.th.holdMsTop : this.th.holdMsBottom;
                return elapsed >= need;
            }

            capFps() {
                const targetDt = 1000 / Math.max(5, this.th.fpsCap);
                const now = Date.now();
                if (this.lastFrameTime === 0) {
                    this.lastFrameTime = now;
                    return true;
                }
                const dt = now - this.lastFrameTime;
                if (dt < targetDt) return false;
                this.lastFrameTime = now;
                return true;
            }

            async onResults(results) {
                if (!this.capFps()) return;

                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.video, 0, 0);

                if (this.mirror) {
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.translate(-this.canvas.width, 0);
                    this.ctx.drawImage(this.video, 0, 0);
                    this.ctx.restore();
                }

                let kneeAng = NaN, hipAng = NaN, ankAng = NaN, depthOk = false, kneeOverToePx = 0;
                let postureFeedback = [];
                if (results.poseLandmarks) {
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    const lm = results.poseLandmarks;
                    const landmarks = {
                        left: {
                            SH: 11, // LEFT_SHOULDER
                            HIP: 23, // LEFT_HIP
                            KNEE: 25, // LEFT_KNEE
                            ANK: 27, // LEFT_ANKLE
                            TOE: 31 // LEFT_FOOT_INDEX
                        }
                    };
                    const side = landmarks[this.side];

                    const shXy = toXY(lm[side.SH], w, h);
                    const hipXy = toXY(lm[side.HIP], w, h);
                    const kneeXy = toXY(lm[side.KNEE], w, h);
                    const ankXy = toXY(lm[side.ANK], w, h);
                    const toeXy = toXY(lm[side.TOE], w, h);

                    kneeAng = angleABC(hipXy, kneeXy, ankXy);
                    hipAng = angleABC(shXy, hipXy, kneeXy);
                    ankAng = angleABC(kneeXy, ankXy, toeXy);

                    const kneeAngS = this.smooth(this.kneeBuf, kneeAng);
                    const hipAngS = this.smooth(this.hipBuf, hipAng);
                    const ankAngS = this.smooth(this.ankleBuf, ankAng);

                    depthOk = (hipXy[1] - kneeXy[1]) > this.th.hipDepthMarginPx;
                    kneeOverToePx = kneeXy[0] - toeXy[0];

                    // Posture feedback
                    postureFeedback.push(`Knee Angle: ${kneeAngS.toFixed(1)}¬∞${kneeAngS <= this.th.kneeDownDeg ? " ‚úì" : ""}`);
                    postureFeedback.push(`Hip Depth: ${depthOk ? "Below knees ‚úì" : "Lower hips"}`);
                    postureFeedback.push(`Knee Position: ${kneeOverToePx > 20 ? "Too far forward" : "Good ‚úì"}`);

                    if (this.showLines) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(ankXy[0], 0);
                        this.ctx.lineTo(ankXy[0], h);
                        this.ctx.strokeStyle = "gray";
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(toeXy[0], kneeXy[1]);
                        this.ctx.lineTo(kneeXy[0], kneeXy[1]);
                        this.ctx.strokeStyle = "yellow";
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(0, kneeXy[1]);
                        this.ctx.lineTo(w, kneeXy[1]);
                        this.ctx.strokeStyle = "lightgray";
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(0, hipXy[1]);
                        this.ctx.lineTo(w, hipXy[1]);
                        this.ctx.strokeStyle = depthOk ? "orange" : "gray";
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }

                    if (!isNaN(kneeAngS)) {
                        if (this.state === "top") {
                            if (kneeAngS <= this.th.kneeDownDeg && depthOk && this.enoughHold("top")) {
                                this.state = "bottom";
                                this.lastStateChange = Date.now();
                                if (this.audibleBeep) beep("low");
                            }
                        } else {
                            if (kneeAngS >= this.th.kneeUpDeg && this.enoughHold("bottom")) {
                                this.state = "top";
                                this.lastStateChange = Date.now();
                                this.repCount++;
                                if (this.audibleBeep) beep("high");
                            }
                        }
                    }
                }

                this.repDiv.textContent = `Reps: ${this.repCount}`;
                this.postureDiv.innerHTML = postureFeedback.join("<br>");
                let msg, color;
                if (this.state === "top") {
                    msg = depthOk ? "Stand tall" : "Sit";
                    color = depthOk ? [40, 220, 40] : [30, 180, 255];
                } else {
                    const elapsed = Date.now() - this.lastStateChange;
                    const need = this.th.holdMsBottom;
                    const remain = Math.max(0, need - elapsed);
                    if (remain > 0) {
                        msg = `Hold... ${Math.floor(remain / 100)}`;
                        color = [0, 180, 255];
                    } else {
                        msg = "Good ‚Äî up!";
                        color = [0, 220, 0];
                    }
                }
                this.drawBigStatus(msg, color);
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    this.video.srcObject = stream;
                    this.video.play();
                    const processFrame = async () => {
                        await this.pose.send({ image: this.video });
                        requestAnimationFrame(processFrame);
                    };
                    processFrame();
                } catch (e) {
                    this.statusDiv.textContent = "Camera error: Check permissions or try Chrome.";
                    console.error(e);
                }
            }
        }

        // Initialize
        const processor = new SquatProcessor();

        // UI Event Listeners
        document.getElementById("show-lines").addEventListener("change", (e) => {
            processor.showLines = e.target.checked;
        });

        document.getElementById("audible-beep").addEventListener("change", (e) => {
            processor.audibleBeep = e.target.checked;
        });

        processor.start();
    </script>
</body>
</html>
